# Jmeter脚本开发

# 一、Jmeter元件

## 1.1执行计划

执行计划用于添加全局的用户定义变量，设置测试计划内线程组的运行顺序，添加执行计划的依赖jar包；

![img](https://wangzaolin.github.io/SoftwareTest/mybook/img/2.2.2.1.jpg)

- 独立运行每个线程组：

勾选，计划内的线程组按照顺序执行；

不勾选，计划内的多个线程组同时执行；默认不勾选；

## 1.2 线程组元件

线程组元件，用于模拟多用户；默认线程组元件包含setup线程组，线程组和tearDown线程组；

- setup线程组内请求最开始执行，常用于登录或数据库连接操作；
- tearDown线程组在最后执行，常用于执行退出登录，数据恢复等操作；
- 线程组内部按照顺序往下执行请求；

![img](https://wangzaolin.github.io/SoftwareTest/mybook/img/2.2.2.2.jpg)

- 线程数：设置并发用户数；
- ramp-up时间：全部线程启动时间
- 循环次数：勾选永远，按照调度器配置时间执行；不勾选永远，按照循环次数执行；

扩展线程组元件

为了实现阶梯性用户增长的场景，通过插件JmeterPlugins-Standard.jar，新增两个线程组元件stepping thread group和ultimate thread group；

JmeterPlugins-Standard.jar下载地址：

链接：https://pan.baidu.com/s/14KvtW8QaNCQJ4vffWwHeug 
提取码：uie1 
下载后，将插件JmeterPlugins-Standard.jar放在jmeter目录下的lib\ext目录中，然后重启jmeter，通过【添加->线程（用户）】可看到新增的线程组元件；

![image-20201230170542720](https://wangzaolin.github.io/SoftwareTest/mybook/img/2.2.2.3.jpg)



- Stepping Thread Group

  用户阶梯性增长，只能按照固定一个步长增长；

![image-20201230183837705](https://wangzaolin.github.io/SoftwareTest/mybook/img/2.2.2.4.jpg)

- Ultimate Thread Group

  用户阶梯性增长，增长步长可控制
  
  ![image-20201231112705278](https://wangzaolin.github.io/SoftwareTest/mybook/img/2.2.2.5.jpg)
  
  ## 1.3 取样器
  
  取样器，用于模拟不同协议的请求；常用的取样器有：http请求、jdbc请求、websocket sampler、调试取样器等；
  
  1）http请求
  
  用于模拟http请求，webservice请求；
  
  ![image-20201231151803570](https://wangzaolin.github.io/SoftwareTest/mybook/img/2.2.2.6.png)
  
  2）jdbc请求
  
  用于模拟发送jdbc请求，执行sql语句，查询结果；需要先导入不同数据库jdbc的jar包，并配置jdbc连接；
  
  ![image-20201231151937936](https://wangzaolin.github.io/SoftwareTest/mybook/img/2.2.2.7.png)                               
  
  3）websocket sampler
  
  websocket sampler用于模拟聊天工具的请求；需要导入依赖包
  
  链接：https://pan.baidu.com/s/1ZE-B6ryBS1qpj9UtbtLpBQ 
  提取码：6a5m 
  
   ![image-20201231152014636](https://wangzaolin.github.io/SoftwareTest/mybook/img/2.2.2.8.png)
  
  4）调试取样器
  
  用于调试脚本，运行脚本之后，可在【察看结果树】中察看到相应的变量值；
  
   ![image-20201231152304535](https://wangzaolin.github.io/SoftwareTest/mybook/img/2.2.2.9.png)
  
  ## 1.4 监控元件
  
  监控元件用于监控脚本执行的结果，常用的监控元件有察看结果树、聚合报告、表格察看结果等；
  
  1）察看结果树
  
  用于单用户调试脚本；可进行正则表达式和json提取响应结果；场景执行时要禁用察看结果树；
  
  ![image-20201231152810605](https://wangzaolin.github.io/SoftwareTest/mybook/img/2.2.2.10.png)
  
  2）聚合报告
  
  聚合报告用于多用户并发时统计测试结果；查看响应时间、处理能力；
  
  ![image-20201231152925495](https://wangzaolin.github.io/SoftwareTest/mybook/img/2.2.2.11.png)

## 1.5 断言元件

断言元件用于校验交易结果是否符合预期的要求，判定交易是否成功；常用的断言元件有：响应断言、json断言、断言持续时间；

1）响应断言

![image-20201231153105429](https://wangzaolin.github.io/SoftwareTest/mybook/img/2.2.2.12.png)

2）json断言

![image-20201231153150052](https://wangzaolin.github.io/SoftwareTest/mybook/img/2.2.2.13.png)

3）断言持续时间

校验交易的响应时间，常用于验证性测试；

![image-20201231153226198](https://wangzaolin.github.io/SoftwareTest/mybook/img/2.2.2.14.jpg)

## 1.6 定时器元件

定时器元件用于配置脚本运行的开始时间，延迟执行或同时执行；常用的定时器元件有固定定时器、同步定时器、统一随机定时器等；

1）固定定时器

固定定时器置于请求的下一级，固定定时器所在的请求延迟执行固定时间；

![image-20201231153506121](https://wangzaolin.github.io/SoftwareTest/mybook/img/2.2.2.15.png)

2）统一随机定时器

置于请求之后，随机延迟执行的时间；

![image-20201231153539768](https://wangzaolin.github.io/SoftwareTest/mybook/img/2.2.2.16.png)

3）同步定时器

置于请求之后，控制请求多用户同步执行；一般用于集合点的测试；

![image-20201231153710469](https://wangzaolin.github.io/SoftwareTest/mybook/img/2.2.2.17.png)

## 1.7 配置元件

配置元件用于配置参数及请求信息，常用的配置元件有csv数据文件、http请求默认值、http信息头管理器、http cookie管理器；

1）csv数据文件

csv数据文件用于配置参数化文件，供请求使用；

![image-20201231153812308](https://wangzaolin.github.io/SoftwareTest/mybook/img/2.2.2.18.png)

2）http请求默认值

http请求默认值配置的值，在后面的请求中为空的值，都使用默认值；

![image-20201231153851263](https://wangzaolin.github.io/SoftwareTest/mybook/img/2.2.2.19.png)

3）http cookie管理器

当请求有cookie值时，添加http cookie管理器后，脚本运行会自动获取cookie值，并拼接到之后的请求中；也可以手动编辑cookie值，供后面的请求使用；

![image-20201231153927402](https://wangzaolin.github.io/SoftwareTest/mybook/img/2.2.2.20.png)

## 1.8 逻辑控制元件

逻辑控制元件用于控制请求的执行逻辑顺序，常用的逻辑控制元件有仅一次控制器、循环控制器、事务控制器、if控制器；

1）仅一次控制器

仅一次控制器控制控制器内部的请求每个用户只会执行1次；（当仅一次控制器位于吞吐量控制器子节点时，吞吐量控制器不生效）

![image-20201231154022785](https://wangzaolin.github.io/SoftwareTest/mybook/img/2.2.2.21.png)

2）循环控制器

控制循环控制器内部的请求循环执行多次

![image-20201231154153410](https://wangzaolin.github.io/SoftwareTest/mybook/img/2.2.2.22.png)

3）if控制器

当if控制器条件满足时，执行控制器内部的请求，一般用于控制场景的比例；

![image-20201231154228547](https://wangzaolin.github.io/SoftwareTest/mybook/img/2.2.2.23.png)

4）事务控制器

把多个请求置于一个事务中，统计事务的响应时间和处理能力；

![image-20201231154315725](https://wangzaolin.github.io/SoftwareTest/mybook/img/2.2.2.24.png)

- generate parent sample:勾选后，将事务中的请求置于事务的子节点中；
- Include duration of timer and pre-post processors in generated sample：勾选，事务响应时间包含定时器的时间和前置处理器的处理时间；

## 1.9 函数助手

函数助手是jmeter封装的函数，可直接调用；常用的函数有：计数器、测试函数、加密函数、生成全局变量、获取全局变量、生成随机数等；

1）计数器函数__counter

计数器用于每个用户的计数

${__counter(TRUE,NUMBER)}

- TRUE，每个用户有自己的计数器；例如：线程数为2，循环执行2次；用户1循环第一次，计数器值为1，循环第二次，计数器值为2；用户2循环执行第1次，计数器值为1，循环执行第2次，计数器值为2；
- FALSE，使用全局计数器，所有用户共用一个计数器，按照执行的顺序，执行第一次，计数器值为1，执行第二次，计数器值为2；
- NUMBER，保存计数器的值到变量NUMBER中；
- 

2）测试函数__jexl3

用于判定条件是否满足，常用于if条件控制其中，和计数器结合使用，设计场景的比例；

${__jexl3(${__counter(TRUE,)} % 4 ==0,)}

当计数器的值对4求余=0时，条件满足，执行该条件控制器下的请求交易；

例如：

并发用户数为8，http请求1和http请求2，要求执行的交易比例为1:3，场景设计如下

线程数8 循环执行8次，符合if控制器1条件的数量为16，符合if控制器2的数量为48，所以请求1和请求2的比例为1:3；

if控制器1：${__jexl3(${__counter(TRUE,)} % 4 == 0,)}

http请求1

if控制器2：${__jexl3(${__counter(TRUE,)} % 4 != 0,)}

http请求2



3）加密函数__MD5

MD5加密函数用于MD5加密；常用于密码的加密；或者生成32位随机数

例如：

密码MD5加密，加密规则为zr+密码+hg

password=${__MD5(zr111111hg,)}

加密之后的结果：5c4fcc5add5d087de1e8534189c687f7



4）设置全局变量

当关联变量需要跨线程组使用的时候，就需要使用【beanshell后置处理器】设置全局变量；

${__setProperty(static_token,${token},)}

将变量token值设置为全局变量，保存到static_token中，可以跨线程组调用；

全局变量调用需要使用全局变量调用函数${__property(static_token)}或${__P(static_token)}



5）随机数函数

${__RandomDate(yyyyMMdd,20200101,20221231,,)}



# 二、jmeter脚本开发

## 2.1 脚本开发方式

jmeter脚本开发方式有3种，分别为：

1）根据接口文档，手动编写请求脚本；

2）根据抓包，手动编写脚本；

3）使用Jmeter代理浏览器录制脚本；

## 2.2 代理浏览器录制脚本

操作步骤：

1）配置浏览器代理；

2）打开jmeter，添加"线程组"，用于存放录制的脚本；

3）在jmeter中，添加“非测试元件->HTTP代理服务器”

![image-20201231161006715](https://wangzaolin.github.io/SoftwareTest/mybook/img/2.2.2.25.png)

4）点击【启动】，打开浏览器进行操作，开始录制脚本；操作完成后，点击【停止】，完成录制；打开jmeter之前添加的线程组，可查看录制到的脚本；

![image-20201231161051642](https://wangzaolin.github.io/SoftwareTest/mybook/img/2.2.2.26.png)

5）整理脚本，把无关联的请求删除，保留需要测试的请求脚本；

# 三、脚本优化

## 3.1 关联

1）关联的目的

​     不同请求之间，有参数值传递，请求的参数是动态值，需要通过其他请求的响应生成；

​     例如：token值，用户登录时，生成token值，登录之后的操作请求都需要带token值才能操作成功，作为一个身份的校验；减少用户操作校验的时间；

2）关联的方法

- 通过正则表达式获取动态值

​     在产生动态数据的请求之后，添加后置处理器【正则表达式提取器】

![image-20210104155531392](https://wangzaolin.github.io/SoftwareTest/mybook/img/2.2.2.27.png)

​	 引用名称：提取动态值后，保存的变量名称；

​     正则表达式："data":"(.*)"，*表示动态值，其他的为动态值的前后文，尽量取更多的前后文，保证关联的动态值唯一；可填写多个模板；

​     模板：$1$，表示取正则表达式中的第一个模板；

​     匹配数字：当匹配的结果有多个时，0表示，随机选取匹配值；1表示选取匹配第一个值；

​     缺省值：当没有匹配到内容时，使用缺省值，可以为空；

​     注：可在察看结果树-响应数据中，测试正则表达式是否正确

- 通过json提取器获取动态值

适用于响应结果为json格式的请求；

在产生动态数据的请求之后，添加后置处理器【Json提取器】

![image-20210104155713212](https://wangzaolin.github.io/SoftwareTest/mybook/img/2.2.2.28.png)

names:变量名称

json path expression:json提取表达式，$.data,其中data为键名，如果有多层则通过多个.号选取，例如$.data[0].goodsID;

Match no:匹配的值，当匹配结果有多个时，0，表示随机匹配，1，表示匹配第一个值；

注：

json提取器表达式也可以在察看结果树-响应数据中进行测试，需要将响应文本展示类型选择json path tester；

## 3.2 参数化

1）目的

参数化是为了模拟真实的多用户操作，对测试数据进行参数化，使用更多的测试数据对系统进行请求；

2）常用参数化方法

- l 用户自定义变量
- l 函数助手：随机函数（random）、时间戳函数(time)、计数器函数(counter)
- l csv数据文件（常用）
- l beanshell
- l jdbc从数据库获取数据

3）csv数据文件

添加方法：添加--配置元件--csv数据文件

![image-20210104160112412](https://wangzaolin.github.io/SoftwareTest/mybook/img/2.2.2.29.png)

- 文件名：分布式测试时使用相对路径，开始测试之前，需要将文件放置到各执行机的对应路径。例如：.\data\user.csv，说明参数化文件的路径为jmeter_home\bin\data\user.csv;

- 文件编码：UTF-8（默认为GB2312)

- 变量名称：参数化文件中变量名称，后面请求中调用变量，使用该名称，用逗号隔开；

- 忽略首行：选择TRUE，表示，忽略参数化文件中第一行的值，一般用于参数化文件首行为变量名称的情况；选择FALSE，不忽略参数化文件首行；

- 分隔符：参数化文件中变量的分隔符，一般为逗号；

- 是否允许带引号：选择TRUE，表示允许参数中带引号，不作为转义字符；

- 遇到文件结束符再次循环：选择TRUE时，循环使用测试数据；

- 遇到文件结束符停止线程：选择TRUE时，当取到最后一个数据时，停止线程；当选择FALSE时，判定遇到文件结束符再次循环的配置，当配置为TRUE时，循环测试，当配置为FALSE时，停止线程；

- 线程共享模式：

  所有线程---表示所有线程组共享测试数据，所有线程组按照顺序选取数据；

  当前线程组---表示当前线程组共享测试数据，当前线程组的用户按照顺序选取数据；每个线程组都从第1个数据开始选取；

  当前线程---表示每个线程独享测试数据，每个用户都从第1个数据开始选择数据；

样例：

Jmter脚本中包含2个线程组：线程组A和线程组B，线程组A下有请求A1，线程组B下有请求B1，在脚本中有参数化文件user.csv，参数值为user01、user02、user03、user04；AB线程组线程数为2，循环2次；

线程共享模式：

1）所有线程

A1取数为：user01、user03、user02、user04

B1取数为：user02、user04、user01、user03

所有线程组的所有用户共享参数化文件，按照顺序选取数据；

2）当前线程组

A1取数为：user01、user02、user03、user04

B1取数为：user01、user02、user03、user04

当前线程组的所有用户共享参数化文件，不同线程组的线程组用户取数独立；

3）当前线程

A1取数为：user01、user02、user01、user02

B1取数为：user01、user02、user01、user02

每个线程独享测试数据，不同用户取数独立；

