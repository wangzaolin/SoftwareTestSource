# 常见性能测试问题：

1、资源使用率高；
2、响应时间长；
3、多用户并发，交易大量报错；
4、多用户并发，处理能力波动大；

# 常见性能问题处理：

## 1、数据库CPU使用率高

案例1：**平台，5用户并发，数据库CPU使用率超过80%；

原因分析：

1）通过监控慢查询，获取耗时较长的SQL语句；

2）查看耗时较长SQL语句的执行计划，确定是否缺少索引，或索引使用不当（小表驱动大表）；

解决方案：

为数据表添加索引，将能够筛选出较少数据的查询条件放在前面；

优化后，最大处理能力由119笔/秒，提升至818笔/秒；



案例2：**电商平台，商品详情查询，40用户并发，处理能力119笔/秒，数据库CPU使用率超标，达96%；

原因分析：

通过查询慢sql和慢sql执行计划，数据表goods_info_spec_detail_rel缺少索引

解决方案：

为goods_info_spec_detail_rel表goods_id和del_flag字段添加索引；

优化后，最大处理能力为937笔/秒，数据库CPU使用率为70%；

## 2、应用服务器CPU使用率高

案例1：
**系统，证书申请下载交易，20用户并发，平均处理能力122笔/秒，应用服务器CPU使用率达78.5%；

原因分析：

通过jdk自带监控工具jvisualvm（需要配置应用服务器jdk，开启远程监控），查看耗CPU较多的线程方法；

解决方案：

应用服务器已达到使用瓶颈，处理能力满足生产需求，暂不处理；

## 3、交易响应时间长

案例1：**电商平台，商品秒杀，10个商品，每个商品库存100，500用户集合点秒杀，平均响应时间长达21秒；

原因分析：

秒杀商品加载到redis缓存，耗时较长；

解决方案：

通过定时任务，提前将秒杀商品加载到redis缓存；

优化后，商品秒杀，平均响应时间2.397秒；

## 4、JAVA应用服务器CPU高

1）查看cpu占用高进程；

通过top命令查看占用CPU较高的进程，获取进程pid；

2）查看CPU较高的线程

通过top -H -p 进程pid，查看耗CPU较多的线程，获取线程PID值；

3）转换线程pid值为16进制

```bash
printf "%x\n" pid值 
```

4）定位线程方法

方法1：

通过jstack命令获取线程堆栈信息

jstack pid值|grep pid(16进制值)

![image-20210312153754249](https://wangzaolin.github.io/SoftwareTest/mybook/img/image-20210312153754249.png)

方法2：

通过jvisualm自带的线程dump获取线程堆栈信息；



## 5、内存溢出

- 内存溢出和内存泄漏

  1）**内存溢出 out of memory**，是指程序在申请内存时，没有足够的内存空间供其使用，出现out of memory；比如申请了一个integer,但给它存了long才能存下的数，那就是内存溢出。

  2）**内存泄露 memory leak**，是指程序在申请内存后，无法释放已申请的内存空间，一次内存泄露危害可以忽略，但内存泄露堆积后果很严重，无论多少内存,迟早会被占光。

  3）避免内存泄漏

  - 尽早释放无用对象的引用
  - 使用字符串处理，避免使用String，应大量使用StringBuffer，每一个String对象都得独立占用内存一块区域
  - 尽量少用静态变量，因为静态变量存放在永久代（方法区），永久代基本不参与垃圾回收
  - 避免在循环中创建对象

  4）避免内存溢出

  - 通过复用对象的方式, 减少产生的对象
  - 大对象需要先压缩后创建
  - 避免或减少内存泄露的情况

  

- 堆内存溢出

1)稳定性压测一段时间后，LR报错，日志报java.lang.OutOfMemoryError.Java heap space。

2)用jmap -histo pid命令dump堆内存使用情况，查看堆内存排名前20个对象，看是否有自己应用程序的方法，从最高的查起，如果有则检查该方法是什么原因造成堆内存溢出。

3)如果前20里没有自己的方法，则用jmap -dump来dump堆内存，在用MAT分析dump下来的堆内存，分析导出内存溢出的方法。

```
#获取耗内存多的pid进程号
top + M
#生成dump文件
jmap -dump:file=test.dump pid
```

4)如果应用程序的方法没有问题，则需要修改JVM参数，修改xms，xmx，调整堆内存参数，一般是增加堆内存



- 栈内存溢出

1)稳定性压测一段时间后，LR报错，日志报Java.Lang.StackOverflowError。

2)修改jvm参数，将xss参数改大，增加栈内存。

3)栈溢出一定是做批量操作引起的，减少批处理数据量。



- 持久代溢出

1)稳定性压测一定时间后，日志报Java.Lang.OutOfMenoryError.PermGen Space。

2)这种原因是由于类、方法描述、字段描述、常量池、访问修饰符等一些静态变量太多，将持久代占满导致持久代溢出。

3)修改jvm配置，将XX:MaxPermSize=256参数调大。尽量减少静态变量。



## 6、线程死锁

1）使用top查看进程id；

2）使用jstack pid进行thread dump分析,如果存在Found 1 deadlock，即存在死锁，查看死锁线程；

![image-20210312165215630](https://wangzaolin.github.io/SoftwareTest/mybook/img/image-20210312165215630.png)